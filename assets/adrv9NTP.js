import{aU as z,r as w,Q as E,an as M,x as h,a_ as b,R as y,a$ as A,b0 as R,b1 as S,o as B,U as C,V as O}from"./-fzKhrZJ.js";function $(e,t,u){let i;z(u)?i={evaluating:u}:i=u||{};const{lazy:c=!1,evaluating:s=void 0,shallow:v=!0,onError:o=R}=i,n=w(!c),r=v?E(t):w(t);let a=0;return M(async l=>{if(!n.value)return;a++;const f=a;let g=!1;s&&Promise.resolve().then(()=>{s.value=!0});try{const p=await e(_=>{l(()=>{s&&(s.value=!1),g||_()})});f===a&&(r.value=p)}catch(p){o(p)}finally{s&&f===a&&(s.value=!1),g=!0}}),c?h(()=>(n.value=!0,r.value)):r}const x=S?window:void 0;function m(e){var t;const u=b(e);return(t=u==null?void 0:u.$el)!=null?t:u}function U(){const e=w(!1),t=C();return t&&B(()=>{e.value=!0},t),e}function V(e){const t=U();return h(()=>(t.value,!!e()))}function D(e,t,u={}){const{window:i=x,...c}=u;let s;const v=V(()=>i&&"ResizeObserver"in i),o=()=>{s&&(s.disconnect(),s=void 0)},n=h(()=>{const l=b(e);return Array.isArray(l)?l.map(f=>m(f)):[m(l)]}),r=y(n,l=>{if(o(),v.value&&i){s=new ResizeObserver(t);for(const f of l)f&&s.observe(f,c)}},{immediate:!0,flush:"post"}),a=()=>{o(),r()};return A(a),{isSupported:v,stop:a}}const d=new Map;function F(e){const t=O();function u(o){var n;const r=d.get(e)||new Set;r.add(o),d.set(e,r);const a=()=>c(o);return(n=t==null?void 0:t.cleanups)==null||n.push(a),a}function i(o){function n(...r){c(n),o(...r)}return u(n)}function c(o){const n=d.get(e);n&&(n.delete(o),n.size||s())}function s(){d.delete(e)}function v(o,n){var r;(r=d.get(e))==null||r.forEach(a=>a(o,n))}return{on:u,once:i,off:c,emit:v,reset:s}}export{m as a,D as b,$ as c,F as u};
