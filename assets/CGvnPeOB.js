import{aW as z,r as w,s as A,U as E,B as h,b1 as m,v as M,b2 as y,b3 as B,b4 as S,o as C,z as O,A as R}from"./BHxOcJ32.js";function I(e,n,u){let i;z(u)?i={evaluating:u}:i=u||{};const{lazy:c=!1,evaluating:s=void 0,shallow:v=!0,onError:o=B}=i,t=w(!c),r=v?A(n):w(n);let a=0;return E(async l=>{if(!t.value)return;a++;const f=a;let b=!1;s&&Promise.resolve().then(()=>{s.value=!0});try{const p=await e(_=>{l(()=>{s&&(s.value=!1),b||_()})});f===a&&(r.value=p)}catch(p){o(p)}finally{s&&f===a&&(s.value=!1),b=!0}}),c?h(()=>(t.value=!0,r.value)):r}const W=S?window:void 0;function g(e){var n;const u=m(e);return(n=u==null?void 0:u.$el)!=null?n:u}function x(){const e=w(!1),n=O();return n&&C(()=>{e.value=!0},n),e}function D(e){const n=x();return h(()=>(n.value,!!e()))}function P(e,n,u={}){const{window:i=W,...c}=u;let s;const v=D(()=>i&&"ResizeObserver"in i),o=()=>{s&&(s.disconnect(),s=void 0)},t=h(()=>{const l=m(e);return Array.isArray(l)?l.map(f=>g(f)):[g(l)]}),r=M(t,l=>{if(o(),v.value&&i){s=new ResizeObserver(n);for(const f of l)f&&s.observe(f,c)}},{immediate:!0,flush:"post"}),a=()=>{o(),r()};return y(a),{isSupported:v,stop:a}}const d=new Map;function U(e){const n=R();function u(o){var t;const r=d.get(e)||new Set;r.add(o),d.set(e,r);const a=()=>c(o);return(t=n==null?void 0:n.cleanups)==null||t.push(a),a}function i(o){function t(...r){c(t),o(...r)}return u(t)}function c(o){const t=d.get(e);t&&(t.delete(o),t.size||s())}function s(){d.delete(e)}function v(o,t){var r;(r=d.get(e))==null||r.forEach(a=>a(o,t))}return{on:u,once:i,off:c,emit:v,reset:s}}export{g as a,P as b,I as c,U as u};
